name: Build Multi-Platform Executables

on:
  push:
    tags:
      - 'v*' # 当推送版本标签时触发 (例如 v1.0.0)
  workflow_dispatch: # 允许手动运行

jobs:
  build:
    # 使用矩阵策略在不同的操作系统上运行作业
    strategy:
      fail-fast: false # 允许一个平台的构建失败，而其他平台继续
      matrix:
        # 定义要运行的操作系统（GitHub Actions Runner）
        os: [ubuntu-latest, windows-latest, macos-latest]
        
        # 可选：如果你需要为每个平台定制更多参数，可以添加一个独立的 matrix 变量，例如：
        # config: 
        #   - { os: ubuntu-latest, name: "linux", extension: "" }
        #   - { os: windows-latest, name: "windows", extension: ".exe" }
        #   - { os: macos-latest, name: "macos", extension: "" }

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        # 根据你的项目需求设置 Python 版本
        uses: actions/setup-python@v5
        with:
          python-version: '3.x' 

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller # 安装 PyInstaller
          # 如果你有 requirements.txt，也安装其他依赖
          pip install -r requirements.txt

      - name: Define App Variables
        # 定义应用名称和主脚本路径，确保它们在所有平台中保持一致
        run: |
          echo "APP_NAME=AioNetMGT" >> $GITHUB_ENV       # 替换为你的应用名称 (例如：YourApp)
          echo "SCRIPT_PATH=aio_net_runner.py" >> $GITHUB_ENV # 替换为你的主脚本路径
        shell: bash

      - name: Build executable
        run: |
          # PyInstaller 的 --name 参数设置为 APP_NAME
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            PYINSTALLER_OPTS="--onefile"
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            # macOS: 使用 --windowed 创建 .app Bundle
            PYINSTALLER_OPTS="--onefile --windowed" 
          else
            # Linux (ubuntu-latest):
            PYINSTALLER_OPTS="--onefile"
          fi
          
          pyinstaller ${{ env.SCRIPT_PATH }} $PYINSTALLER_OPTS --name ${{ env.APP_NAME }}
        shell: bash

      - name: Rename and prepare artifact
        run: |
          PLATFORM_NAME=""
          FINAL_PATH=""
          
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            PLATFORM_NAME="windows"
            # Windows 的可执行文件是 dist/APP_NAME.exe
            FINAL_PATH="dist/${{ env.APP_NAME }}.exe"
            echo "EXECUTABLE_NAME=${{ env.APP_NAME }}_${PLATFORM_NAME}.exe" >> $GITHUB_ENV
            
            # 重命名文件
            mv "${FINAL_PATH}" "${{ env.APP_NAME }}_${PLATFORM_NAME}.exe"
            echo "ARTIFACT_PATH=${{ env.APP_NAME }}_${PLATFORM_NAME}.exe" >> $GITHUB_ENV
            
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            PLATFORM_NAME="macos"
            # macOS 的应用是一个文件夹：dist/APP_NAME.app
            FINAL_PATH="dist/${{ env.APP_NAME }}.app"
            ZIP_NAME="${{ env.APP_NAME }}_${PLATFORM_NAME}.zip"

            # 压缩 .app 文件夹
            zip -r "${ZIP_NAME}" "${FINAL_PATH}"
            
            echo "EXECUTABLE_NAME=${ZIP_NAME}" >> $GITHUB_ENV
            echo "ARTIFACT_PATH=${ZIP_NAME}" >> $GITHUB_ENV
            
          else
            PLATFORM_NAME="linux"
            # Linux 的可执行文件是 dist/APP_NAME
            FINAL_PATH="dist/${{ env.APP_NAME }}"
            FINAL_NAME="${{ env.APP_NAME }}_${PLATFORM_NAME}"
            
            # 确保 Linux 可执行文件具有执行权限
            chmod +x "${FINAL_PATH}"
            
            # 重命名文件
            mv "${FINAL_PATH}" "${FINAL_NAME}"
            
            echo "EXECUTABLE_NAME=${FINAL_NAME}" >> $GITHUB_ENV
            echo "ARTIFACT_PATH=${FINAL_NAME}" >> $GITHUB_ENV
          fi
          
        # 注意：使用 bash shell，即使在 Windows 上，也能更好地处理文件路径和变量
        shell: bash

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.EXECUTABLE_NAME }}
          path: ${{ env.ARTIFACT_PATH }}
